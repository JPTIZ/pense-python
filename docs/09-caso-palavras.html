<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Estudo de caso: jogos de palavras - Pense em Python</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Pense como um cientista da computação">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introducao.html">Pense em Python</a></li><li class="affix"><a href="00-prefacio.html">Prefácio</a></li><li><a href="01-jornada.html"><strong aria-hidden="true">1.</strong> A jornada do programa</a></li><li><a href="02-vars-expr-instr.html"><strong aria-hidden="true">2.</strong> Variáveis, expressões e instruções</a></li><li><a href="03-funcoes.html"><strong aria-hidden="true">3.</strong> Funções</a></li><li><a href="04-caso-interface.html"><strong aria-hidden="true">4.</strong> Estudo de caso: projeto de interface</a></li><li><a href="05-cond-recur.html"><strong aria-hidden="true">5.</strong> Condicionais e recursividade</a></li><li><a href="06-funcoes-result.html"><strong aria-hidden="true">6.</strong> Funções com resultado</a></li><li><a href="07-iteracao.html"><strong aria-hidden="true">7.</strong> Iteração</a></li><li><a href="08-strings.html"><strong aria-hidden="true">8.</strong> Strings</a></li><li><a href="09-caso-palavras.html" class="active"><strong aria-hidden="true">9.</strong> Estudo de caso: jogos de palavras</a></li><li><a href="10-listas.html"><strong aria-hidden="true">10.</strong> Listas</a></li><li><a href="11-dicionarios.html"><strong aria-hidden="true">11.</strong> Dicionários</a></li><li><a href="12-tuplas.html"><strong aria-hidden="true">12.</strong> Tuplas</a></li><li><a href="13-caso-estruturas.html"><strong aria-hidden="true">13.</strong> Estudo de caso: seleção de estrutura de dados</a></li><li><a href="14-arquivos.html"><strong aria-hidden="true">14.</strong> Arquivos</a></li><li><a href="15-classes-objetos.html"><strong aria-hidden="true">15.</strong> Classes e objetos</a></li><li><a href="16-classes-funcoes.html"><strong aria-hidden="true">16.</strong> Classes e funções</a></li><li><a href="17-classes-metodos.html"><strong aria-hidden="true">17.</strong> Classes e métodos</a></li><li><a href="18-heranca.html"><strong aria-hidden="true">18.</strong> Herança</a></li><li><a href="19-extra.html"><strong aria-hidden="true">19.</strong> Extra</a></li><li class="affix"><a href="A-depuracao.html">Apêndice A: Depuração</a></li><li class="affix"><a href="B-analise-algorit.html">Apêndice B: Análise de algoritmos</a></li><li class="affix"><a href="C-colofao-autor.html">Colofão / Sobre o Autor</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Pense em Python</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="09-caso-palavras.html#capítulo-9-estudo-de-caso-jogos-de-palavras" id="capítulo-9-estudo-de-caso-jogos-de-palavras"><h1>Capítulo 9: Estudo de caso: jogos de palavras</h1></a>
<p>Este capítulo apresenta o segundo estudo de caso que envolve solucionar quebra-cabeças usando palavras com certas propriedades. Por exemplo, encontraremos os palíndromos mais longos em inglês e procuraremos palavras cujas letras apareçam em ordem alfabética. E apresentarei outro plano de desenvolvimento de programa: a redução a um problema resolvido anteriormente.</p>
<a class="header" href="09-caso-palavras.html#91---leitura-de-listas-de-palavras" id="91---leitura-de-listas-de-palavras"><h2>9.1 - Leitura de listas de palavras</h2></a>
<p>Para os exercícios deste capítulo vamos usar uma lista de palavras em inglês. Há muitas listas de palavras disponíveis na internet, mas a mais conveniente ao nosso propósito é uma das listas de palavras disponibilizadas em domínio público por Grady Ward como parte do projeto lexical Moby (ver http://wikipedia.org/wiki/Moby_Project). É uma lista de 113.809 palavras cruzadas oficiais; isto é, as palavras que se consideram válidas em quebra-cabeças de palavras cruzadas e outros jogos de palavras. Na coleção Moby, o nome do arquivo é 113809of.fic; você pode baixar uma cópia, com um nome mais simples como words.txt, de http://thinkpython2.com/code/words.txt.</p>
<p>Este arquivo está em texto simples, então você pode abri-lo com um editor de texto, mas também pode lê-lo no Python. A função integrada open recebe o nome do arquivo como um parâmetro e retorna um objeto de arquivo que você pode usar para ler o arquivo.</p>
<pre><code class="language-python">&gt;&gt;&gt; fin = open('words.txt')
</code></pre>
<p><code>fin</code> é um nome comum de objeto de arquivo usado para entrada de dados. O objeto de arquivo oferece vários métodos de leitura, inclusive readline, que lê caracteres no arquivo até chegar a um comando de nova linha, devolvendo o resultado como uma string:</p>
<pre><code class="language-python">&gt;&gt;&gt; fin.readline()
'aa\r\n'
</code></pre>
<p>A primeira palavra nesta lista específica é “aa”, uma espécie de lava. A sequência <code>'\r\n'</code> representa dois caracteres que representam espaços em branco (whitespace), um retorno de carro e uma nova linha, que separa esta palavra da seguinte.</p>
<p>O objeto de arquivo grava a posição em que está no arquivo, então se você chamar readline mais uma vez, receberá a seguinte palavra:</p>
<pre><code class="language-python">&gt;&gt;&gt; fin.readline()
'aah\r\n'
</code></pre>
<p>A palavra seguinte é “aah”, uma palavra perfeitamente legítima, então pare de olhar para mim desse jeito. Ou, se é o whitespace que está incomodando você, podemos nos livrar dele com o método de string <code>strip</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; line = fin.readline()
&gt;&gt;&gt; word = line.strip()
&gt;&gt;&gt; word
'aahed'
</code></pre>
<p>Você também pode usar um objeto de arquivo como parte de um loop <code>for</code>. Este programa lê words.txt e imprime cada palavra, uma por linha:</p>
<pre><code class="language-python">fin = open('words.txt')
for line in fin:
    word = line.strip()
    print(word)
</code></pre>
<a class="header" href="09-caso-palavras.html#92---exercícios" id="92---exercícios"><h2>9.2 - Exercícios</h2></a>
<p>Há soluções para estes exercícios na próxima seção. Mas é bom você tentar fazer cada um antes de ver as soluções.</p>
<a class="header" href="09-caso-palavras.html#exercício-91" id="exercício-91"><h3>Exercício 9.1</h3></a>
<p>Escreva um programa que leia words.txt e imprima apenas as palavras com mais de 20 caracteres (sem contar whitespace).</p>
<a class="header" href="09-caso-palavras.html#exercício-92" id="exercício-92"><h3>Exercício 9.2</h3></a>
<p>Em 1939, Ernest Vincent Wright publicou uma novela de 50.000 palavras, chamada Gadsby, que não contém a letra “e”. Como o “e” é a letra mais comum em inglês, isso não é algo fácil de fazer.</p>
<p>Na verdade, é difícil até construir um único pensamento sem usar o símbolo mais comum do idioma. No início é lento, mas com prudência e horas de treino, vai ficando cada vez mais fácil.</p>
<pre><code class="language-python">Muito bem, agora eu vou parar.
</code></pre>
<p>Escreva uma função chamada <code>has_no_e</code> que retorne <code>True</code> se a palavra dada não tiver a letra “e” nela.</p>
<p>Altere seu programa na seção anterior para imprimir apenas as palavras que não têm “e” e calcule a porcentagem de palavras na lista que não têm “e”.</p>
<a class="header" href="09-caso-palavras.html#exercício-93" id="exercício-93"><h3>Exercício 9.3</h3></a>
<p>Escreva uma função chamada avoids que receba uma palavra e uma série de letras proibidas, e retorne True se a palavra não usar nenhuma das letras proibidas.</p>
<p>Altere o código para que o usuário digite uma série de letras proibidas e o programa imprima o número de palavras que não contêm nenhuma delas. Você pode encontrar uma combinação de cinco letras proibidas que exclua o menor número possível de palavras?</p>
<a class="header" href="09-caso-palavras.html#exercício-94" id="exercício-94"><h3>Exercício 9.4</h3></a>
<p>Escreva uma função chamada <code>uses_only</code> que receba uma palavra e uma série de letras e retorne <code>True</code>, se a palavra só contiver letras da lista. Você pode fazer uma frase usando só as letras acefhlo? Que não seja “Hoe alfalfa?”</p>
<a class="header" href="09-caso-palavras.html#exercício-95" id="exercício-95"><h3>Exercício 9.5</h3></a>
<p>Escreva uma função chamada <code>uses_all</code> que receba uma palavra e uma série de letras obrigatórias e retorne <code>True</code> se a palavra usar todas as letras obrigatórias pelo menos uma vez. Quantas palavras usam todas as vogais (aeiou)? E que tal aeiouy?</p>
<a class="header" href="09-caso-palavras.html#exercício-96" id="exercício-96"><h3>Exercício 9.6</h3></a>
<p>Escreva uma função chamada <code>is_abecedarian</code> que retorne <code>True</code> se as letras numa palavra aparecerem em ordem alfabética (tudo bem se houver letras duplas). Quantas palavras em ordem alfabética existem?</p>
<a class="header" href="09-caso-palavras.html#93---busca" id="93---busca"><h2>9.3 - Busca</h2></a>
<p>Todos os exercícios na seção anterior têm algo em comum; eles podem ser resolvidos com o modelo de busca que vimos em <a href="./08-strings.md#86---buscando">Buscando</a>. O exemplo mais simples é:</p>
<pre><code class="language-python">def has_no_e(word):
    for letter in word:
        if letter == 'e':
            return False
    return True
</code></pre>
<p>O loop for atravessa os caracteres em word. Se encontrarmos a letra “e”, podemos retornar False imediatamente; se não for o caso, temos que ir à letra seguinte. Se sairmos do loop normalmente, isso quer dizer que não encontramos um “e”, então retornamos True.</p>
<p>Você pode escrever esta função de forma mais concisa usando o operador in, mas comecei com esta versão porque ela demonstra a lógica do modelo de busca.</p>
<p><code>avoids</code> é uma versão mais geral de <code>has_no_e</code>, mas tem a mesma estrutura:</p>
<pre><code class="language-python">def avoids(word, forbidden):
    for letter in word:
        if letter in forbidden:
            return False
    return True
</code></pre>
<p>Podemos retornar <code>False</code> logo que encontrarmos uma letra proibida; se chegarmos ao fim do loop, retornamos <code>True</code>.</p>
<p><code>uses_only</code> é semelhante, exceto pelo sentido da condição, que se inverte:</p>
<pre><code class="language-python">def uses_only(word, available):
    for letter in word:
        if letter not in available:
            return False
    return True
</code></pre>
<p>Em vez de uma lista de letras proibidas, temos uma lista de letras disponíveis. Se encontrarmos uma letra em word que não está em <code>available</code>, podemos retornar <code>False</code>.</p>
<p><code>uses_all</code> é semelhante, mas invertemos a função da palavra e a string de letras:</p>
<pre><code class="language-python">def uses_all(word, required):
    for letter in required:
        if letter not in word:
            return False
    return True
</code></pre>
<p>Em vez de atravessar as letras em <code>word</code>, o loop atravessa as letras obrigatórias. Se alguma das letras obrigatórias não aparecer na palavra, podemos retornar <code>False</code>.</p>
<p>Se você realmente estivesse pensando como um cientista da computação, teria reconhecido que <code>uses_all</code> foi um exemplo de um problema resolvido anteriormente e escreveria:</p>
<pre><code class="language-python">def uses_all(word, required):
    return uses_only(required, word)
</code></pre>
<p>Esse é um exemplo de um plano de desenvolvimento de programa chamado <strong>redução a um problema resolvido anteriormente</strong>, ou seja, você reconhece o problema no qual está trabalhando como um exemplo de um problema já resolvido e aplica uma solução existente.</p>
<a class="header" href="09-caso-palavras.html#94---loop-com-índices" id="94---loop-com-índices"><h2>9.4 - Loop com índices</h2></a>
<p>Escrevi as funções na seção anterior com loops <code>for</code> porque eu só precisava dos caracteres nas strings; não precisava fazer nada com os índices.</p>
<p>Para <code>is_abecedarian</code> temos que comparar letras adjacentes, o que é um pouco complicado para o loop for:</p>
<pre><code class="language-python">def is_abecedarian(word):
    previous = word[0]
    for c in word:
        if c &lt; previous:
            return False
        previous = c
    return True
</code></pre>
<p>Uma alternativa é usar a recursividade:</p>
<pre><code class="language-python">def is_abecedarian(word):
    if len(word) &lt;= 1:
        return True
    if word[0] &gt; word[1]:
        return False
    return is_abecedarian(word[1:])
</code></pre>
<p>Outra opção é usar um loop <code>while</code>:</p>
<pre><code class="language-python">def is_abecedarian(word):
    i = 0
    while i &lt; len(word)-1:
        if word[i+1] &lt; word[i]:
            return False
        i = i+1
    return True
</code></pre>
<p>O loop começa com <code>i == 0</code> e termina quando <code>i == len(word)-1</code>. Cada vez que passa pelo loop, o programa compara o “i-ésimo” caractere (que você pode considerar o caractere atual) com o caractere de posição <code>i+1</code> (que pode ser considerado o caractere seguinte).</p>
<p>Se o próximo caractere for de uma posição anterior (alfabeticamente anterior) à atual, então descobrimos uma quebra na tendência alfabética, e retornamos <code>False</code>.</p>
<p>Se chegarmos ao fim do loop sem encontrar uma quebra, então a palavra passa no teste. Para convencer-se de que o loop termina corretamente, considere um exemplo como <code>'flossy'</code>. O comprimento da palavra é 6, então o loop é executado pela última vez quando i for igual a 4, que é o índice do segundo caractere de trás para frente. Na última iteração, o programa compara o penúltimo caractere com o último, que é o que queremos.</p>
<p>Aqui está uma versão de <code>is_palindrome</code> (veja o Exercício 6.3) que usa dois índices: um começa no início e aumenta; o outro começa no final e diminui.</p>
<pre><code class="language-python">def is_palindrome(word):
    i = 0
    j = len(word)-1
    while i&lt;j:
        if word[i] != word[j]:
            return False
        i = i+1
        j = j-1
    return True
</code></pre>
<p>Ou podemos reduzir a um problema resolvido anteriormente e escrever:</p>
<pre><code class="language-python">def is_palindrome(word):
    return is_reverse(word, word)
</code></pre>
<p>Usando <code>is_reverse</code> da seção 8.11.</p>
<a class="header" href="09-caso-palavras.html#95---depuração" id="95---depuração"><h2>9.5 - Depuração</h2></a>
<p>Testar programas é difícil. As funções neste capítulo são relativamente fáceis para testar porque é possível verificar os resultados à mão. Ainda assim, pode ser difícil ou até impossível escolher um grupo de palavras que teste todos os erros possíveis.</p>
<p>Tomando <code>has_no_e</code> como exemplo, há dois casos óbvios para verificar: as palavras que têm um ‘e’ devem retornar False, e as palavras que não têm devem retornar True. Não deverá ser um problema pensar em um exemplo de cada uma.</p>
<p>Dentro de cada caso, há alguns subcasos menos óbvios. Entre as palavras que têm um “e”, você deve testar palavras com um “e” no começo, no fim e em algum lugar no meio. Você deve testar palavras longas, palavras curtas e palavras muito curtas, como a string vazia. A string vazia é um exemplo de um caso especial, não óbvio, onde erros muitas vezes espreitam.</p>
<p>Além dos casos de teste que você gerar, também pode ser uma boa ideia testar seu programa com uma lista de palavras como words.txt. Ao analisar a saída, pode ser que os erros apareçam, mas tenha cuidado: você pode pegar um tipo de erro (palavras que não deveriam ser incluídas, mas foram) e não outro (palavras que deveriam ser incluídas, mas não foram).</p>
<p>Em geral, o teste pode ajudar a encontrar bugs, mas não é fácil gerar um bom conjunto de casos de teste, e, mesmo se conseguir, não há como ter certeza de que o programa está correto. Segundo um lendário cientista da computação:</p>
<p>Testar programas pode ser usado para mostrar a presença de bugs, mas nunca para mostrar a ausência deles! – Edsger W. Dijkstra</p>
<a class="header" href="09-caso-palavras.html#96---glossário" id="96---glossário"><h2>9.6 - Glossário</h2></a>
<dl>
<dt><a id="glos:objeto de arquivo" href="09-caso-palavras.html#termo:objeto de arquivo">objeto de arquivo</a></dt>
<dd>Um valor que representa um arquivo aberto.</dd>
<dt><a id="glos:redução a um problema resolvido anteriormente" href="09-caso-palavras.html#termo:redução a um problema resolvido anteriormente">redução a um problema resolvido anteriormente</a></dt>
<dd>Um modo de resolver um problema expressando-o como uma instância de um problema resolvido anteriormente.</dd>
<dt><a id="glos:caso especial" href="09-caso-palavras.html#termo:caso especial">caso especial</a></dt>
<dd>Um caso de teste que é atípico ou não é óbvio (e com probabilidade menor de ser tratado corretamente).</dd>
</dl>
<a class="header" href="09-caso-palavras.html#97---exercícios" id="97---exercícios"><h2>9.7 - Exercícios</h2></a>
<a class="header" href="09-caso-palavras.html#exercício-97" id="exercício-97"><h3>Exercício 9.7</h3></a>
<p>Esta pergunta é baseada em um quebra-cabeça veiculado em um programa de rádio chamado Car Talk (http://www.cartalk.com/content/puzzlers):</p>
<p>Dê uma palavra com três letras duplas consecutivas. Vou dar exemplos de palavras que quase cumprem a condição, mas não chegam lá. Por exemplo, a palavra committee, c-o-m-m-i-t-t-e-e. Seria perfeita se não fosse aquele ‘i’ que se meteu ali no meio. Ou Mississippi: M-i-s-s-i-s-s-i-p-p-i. Se pudesse tirar aqueles ‘is’, daria certo. Mas há uma palavra que tem três pares consecutivos de letras e, que eu saiba, pode ser a única palavra que existe. É claro que provavelmente haja mais umas 500, mas só consigo pensar nessa. Qual é a palavra?</p>
<p>Escreva um programa que a encontre.</p>
<p>Solução: http://thinkpython2.com/code/cartalk1.py.</p>
<a class="header" href="09-caso-palavras.html#exercício-98" id="exercício-98"><h3>Exercício 9.8</h3></a>
<p>Aqui está outro quebra-cabeça do programa Car Talk (http://www.cartalk.com/content/puzzlers):</p>
<p>“Estava dirigindo outro dia e percebi algo no hodômetro que chamou a minha atenção. Como a maior parte dos hodômetros, ele mostra seis dígitos, apenas em milhas inteiras. Por exemplo, se o meu carro tivesse 300.000 milhas, eu veria 3-0-0-0-0-0.</p>
<p>“Agora, o que vi naquele dia foi muito interessante. Notei que os últimos 4 dígitos eram um palíndromo; isto é, podiam ser lidos da mesma forma no sentido correto e no sentido inverso. Por exemplo, 5-4-4-5 é um palíndromo, então no meu hodômetro poderia ser 3-1-5-4-4-5.</p>
<p>“Uma milha depois, os últimos 5 números formaram um palíndromo. Por exemplo, poderia ser 3-6-5-4-5-6. Uma milha depois disso, os 4 números do meio, dentro dos 6, formavam um palíndromo. E adivinhe só? Um milha depois, todos os 6 formavam um palíndromo!</p>
<p>“A pergunta é: o que estava no hodômetro quando olhei primeiro?”</p>
<p>Escreva um programa Python que teste todos os números de seis dígitos e imprima qualquer número que satisfaça essas condições.</p>
<p>Solução: http://thinkpython2.com/code/cartalk2.py.</p>
<a class="header" href="09-caso-palavras.html#exercício-99" id="exercício-99"><h3>Exercício 9.9</h3></a>
<p>Aqui está outro problema do Car Talk que você pode resolver com uma busca (http://www.cartalk.com/content/puzzlers):</p>
<p>“Há pouco tempo recebi uma visita da minha mãe e percebemos que os dois dígitos que compõem a minha idade, quando invertidos, representavam a idade dela. Por exemplo, se ela tem 73 anos, eu tenho 37 anos. Ficamos imaginando com que frequência isto aconteceu nos anos anteriores, mas acabamos mudando de assunto e não chegamos a uma resposta.</p>
<p>“Quando cheguei em casa, cheguei à conclusão de que os dígitos das nossas idades tinham sido reversíveis seis vezes até então. Também percebi que, se tivéssemos sorte, isso aconteceria novamente dali a alguns anos, e se fôssemos muito sortudos, aconteceria mais uma vez depois disso. Em outras palavras, aconteceria 8 vezes no total. Então a pergunta é: quantos anos tenho agora?”</p>
<p>Escreva um programa em Python que busque soluções para esse problema. Dica: pode ser uma boa ideia usar o método de string zfill.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="08-strings.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="10-listas.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="08-strings.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="10-listas.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
