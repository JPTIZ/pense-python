<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Arquivos - Pense em Python</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Pense como um cientista da computação">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introducao.html">Pense em Python</a></li><li class="affix"><a href="00-prefacio.html">Prefácio</a></li><li><a href="01-jornada.html"><strong aria-hidden="true">1.</strong> A jornada do programa</a></li><li><a href="02-vars-expr-instr.html"><strong aria-hidden="true">2.</strong> Variáveis, expressões e instruções</a></li><li><a href="03-funcoes.html"><strong aria-hidden="true">3.</strong> Funções</a></li><li><a href="04-caso-interface.html"><strong aria-hidden="true">4.</strong> Estudo de caso: projeto de interface</a></li><li><a href="05-cond-recur.html"><strong aria-hidden="true">5.</strong> Condicionais e recursividade</a></li><li><a href="06-funcoes-result.html"><strong aria-hidden="true">6.</strong> Funções com resultado</a></li><li><a href="07-iteracao.html"><strong aria-hidden="true">7.</strong> Iteração</a></li><li><a href="08-strings.html"><strong aria-hidden="true">8.</strong> Strings</a></li><li><a href="09-caso-palavras.html"><strong aria-hidden="true">9.</strong> Estudo de caso: jogos de palavras</a></li><li><a href="10-listas.html"><strong aria-hidden="true">10.</strong> Listas</a></li><li><a href="11-dicionarios.html"><strong aria-hidden="true">11.</strong> Dicionários</a></li><li><a href="12-tuplas.html"><strong aria-hidden="true">12.</strong> Tuplas</a></li><li><a href="13-caso-estruturas.html"><strong aria-hidden="true">13.</strong> Estudo de caso: seleção de estrutura de dados</a></li><li><a href="14-arquivos.html" class="active"><strong aria-hidden="true">14.</strong> Arquivos</a></li><li><a href="15-classes-objetos.html"><strong aria-hidden="true">15.</strong> Classes e objetos</a></li><li><a href="16-classes-funcoes.html"><strong aria-hidden="true">16.</strong> Classes e funções</a></li><li><a href="17-classes-metodos.html"><strong aria-hidden="true">17.</strong> Classes e métodos</a></li><li><a href="18-heranca.html"><strong aria-hidden="true">18.</strong> Herança</a></li><li><a href="19-extra.html"><strong aria-hidden="true">19.</strong> Extra</a></li><li class="affix"><a href="A-depuracao.html">Apêndice A: Depuração</a></li><li class="affix"><a href="B-analise-algorit.html">Apêndice B: Análise de algoritmos</a></li><li class="affix"><a href="C-colofao-autor.html">Colofão / Sobre o Autor</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Pense em Python</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="14-arquivos.html#capítulo-14-arquivos" id="capítulo-14-arquivos"><h1>Capítulo 14: Arquivos</h1></a>
<p>Este capítulo apresenta a ideia de programas “persistentes”, que mantêm dados em armazenamento permanente, e mostra como usar tipos diferentes de armazenamento permanente, como arquivos e bancos de dados.</p>
<a class="header" href="14-arquivos.html#141---persistência" id="141---persistência"><h2>14.1 - Persistência</h2></a>
<p>A maioria dos programas que vimos até agora são transitórios, porque são executados por algum tempo e produzem alguma saída, mas, quando terminam, seus dados desaparecem. Se executar o programa novamente, ele começa novamente do zero.</p>
<p>Outros programas são persistentes: rodam por muito tempo (ou todo o tempo); mantêm pelo menos alguns dos seus dados em armazenamento permanente (uma unidade de disco rígido, por exemplo); e se são desligados e reiniciados, continuam de onde pararam.</p>
<p>Exemplos de programas persistentes são sistemas operacionais, que rodam praticamente durante todo o tempo em que um computador está ligado, e servidores web, que rodam todo o tempo, esperando pedidos de entrada na rede.</p>
<p>Uma das formas mais simples para programas manterem seus dados é lendo e escrevendo arquivos de texto. Já vimos programas que leem arquivos de texto; neste capítulo veremos programas que os escrevem.</p>
<p>Uma alternativa é armazenar o estado do programa em um banco de dados. Neste capítulo apresentarei um banco de dados simples e um módulo, pickle, que facilita o armazenamento de dados de programas.</p>
<a class="header" href="14-arquivos.html#142---leitura-e-escrita" id="142---leitura-e-escrita"><h2>14.2 - Leitura e escrita</h2></a>
<p>Um arquivo de texto é uma sequência de caracteres armazenados em um meio permanente como uma unidade de disco rígido, pendrive ou CD-ROM. Vimos como abrir e ler um arquivo em “Leitura de listas de palavras” na página 133.</p>
<p>Para escrever um arquivo texto, é preciso abri-lo com o modo <code>'w'</code> como segundo parâmetro:</p>
<pre><code class="language-python">&gt;&gt;&gt; fout = open('output.txt', 'w')
</code></pre>
<p>Se o arquivo já existe, abri-lo em modo de escrita elimina os dados antigos e começa tudo de novo, então tenha cuidado! Se o arquivo não existir, é criado um arquivo novo.</p>
<p><code>open</code> retorna um objeto de arquivo que fornece métodos para trabalhar com o arquivo. O método write põe dados no arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; line1 = &quot;This here's the wattle,\n&quot;
&gt;&gt;&gt; fout.write(line1)
24
</code></pre>
<p>O valor devolvido é o número de caracteres que foram escritos. O objeto de arquivo monitora a posição em que está, então se você chamar <code>write</code> novamente, os novos dados são acrescentados ao fim do arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; line2 = &quot;the emblem of our land.\n&quot;
&gt;&gt;&gt; fout.write(line2)
24
</code></pre>
<p>Ao terminar de escrever, você deve fechar o arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; fout.close()
</code></pre>
<p>Se não fechar o arquivo, ele é fechado para você quando o programa termina.</p>
<a class="header" href="14-arquivos.html#143---operador-de-formatação" id="143---operador-de-formatação"><h2>14.3 - Operador de formatação</h2></a>
<p>O argumento de <code>write</code> tem que ser uma string, então, se quisermos inserir outros valores em um arquivo, precisamos convertê-los em strings. O modo mais fácil de fazer isso é com <code>str</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 52
&gt;&gt;&gt; fout.write(str(x))
</code></pre>
<p>Uma alternativa é usar o operador de formatação, <code>%</code>. Quando aplicado a números inteiros, <code>%</code> é o operador de módulo. No entanto, quando o primeiro operando é uma string, <code>%</code> é o operador de formatação.</p>
<p>O primeiro operando é a string de formatação, que contém uma ou várias sequências de formatação que especificam como o segundo operando deve ser formatado. O resultado é uma string.</p>
<p>Por exemplo, a sequência de formatação '%d' significa que o segundo operando deve ser formatado como um número inteiro decimal:</p>
<pre><code class="language-python">&gt;&gt;&gt; camels = 42
&gt;&gt;&gt; '%d' % camels
'42'
</code></pre>
<p>O resultado é a string <code>'42'</code>, que não deve ser confundida com o valor inteiro <code>42</code>.</p>
<p>Uma sequência de formatação pode aparecer em qualquer lugar na string, então você pode embutir um valor em uma sentença:</p>
<pre><code class="language-python">&gt;&gt;&gt; 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
</code></pre>
<p>Se houver mais de uma sequência de formatação na string, o segundo argumento tem que ser uma tupla. Cada sequência de formatação é combinada com um elemento da tupla, nesta ordem.</p>
<p>O seguinte exemplo usa <code>'%d'</code> para formatar um número inteiro, <code>'%g'</code> para formatar um número de ponto flutuante e <code>'%s'</code> para formatar qualquer objeto como uma string:</p>
<pre><code class="language-python">&gt;&gt;&gt; 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
</code></pre>
<p>O número de elementos na tupla tem de corresponder ao número de sequências de formatação na string. Além disso, os tipos dos elementos têm de corresponder às sequências de formatação:</p>
<pre><code class="language-python">&gt;&gt;&gt; '%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
&gt;&gt;&gt; '%d' % 'dollars'
TypeError: %d format: a number is required, not str
</code></pre>
<p>No primeiro exemplo não há elementos suficientes; no segundo, o elemento é do tipo incorreto.</p>
<p>Para obter mais informações sobre o operador de formato, veja https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting. Você pode ler sobre uma alternativa mais eficiente, o método de formatação de strings, em https://docs.python.org/3/library/stdtypes.html#str.format.</p>
<a class="header" href="14-arquivos.html#144---nomes-de-arquivo-e-caminhos" id="144---nomes-de-arquivo-e-caminhos"><h2>14.4 - Nomes de arquivo e caminhos</h2></a>
<p>Os arquivos são organizados em diretórios (também chamados de “pastas”). Cada programa em execução tem um “diretório atual”, que é o diretório-padrão da maior parte das operações. Por exemplo, quando você abre um arquivo de leitura, Python o procura no diretório atual.</p>
<p>O módulo <code>os</code> fornece funções para trabalhar com arquivos e diretórios (“os” é a abreviação de “sistema operacional” em inglês). <code>os.getcwd</code> devolve o nome do diretório atual:</p>
<pre><code class="language-python">&gt;&gt;&gt; import os
&gt;&gt;&gt; cwd = os.getcwd()
&gt;&gt;&gt; cwd
'/home/dinsdale'
</code></pre>
<p><code>cwd</code> é a abreviação de “diretório de trabalho atual” em inglês. O resultado neste exemplo é <code>/home/dinsdale</code>, que é o diretório-padrão de um usuário chamado “dinsdale”.</p>
<p>Uma string como <code>'/home/dinsdale'</code>, que identifica um arquivo ou diretório, é chamada de caminho (path).</p>
<p>Um nome de arquivo simples, como <code>memo.txt</code>, também é considerado um caminho, mas é um caminho relativo, porque se relaciona ao diretório atual. Se o diretório atual é <code>/home/dinsdale</code>, o nome de arquivo <code>memo.txt</code> se referiria a <code>/home/dinsdale/memo.txt</code>.</p>
<p>Um caminho que começa com <code>/</code> não depende do diretório atual; isso é chamado de caminho absoluto. Para encontrar o caminho absoluto para um arquivo, você pode usar <code>os.path.abspath</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'
</code></pre>
<p><code>os.path</code> fornece outras funções para trabalhar com nomes de arquivo e caminhos. Por exemplo, <code>os.path.exists</code> que verifica se um arquivo ou diretório existe:</p>
<pre><code class="language-python">&gt;&gt;&gt; os.path.exists('memo.txt')
True
</code></pre>
<p>Se existir, <code>os.path.isdir</code> verifica se é um diretório:</p>
<pre><code class="language-python">&gt;&gt;&gt; os.path.isdir('memo.txt')
False
&gt;&gt;&gt; os.path.isdir('/home/dinsdale')
True
</code></pre>
<p>De forma similar, <code>os.path.isfile</code> verifica se é um arquivo.</p>
<p>os.listdir retorna uma lista dos arquivos (e outros diretórios) no diretório dado:</p>
<pre><code class="language-python"> &gt;&gt;&gt; os.listdir(cwd)
['music', 'photos', 'memo.txt']
</code></pre>
<p>Para demonstrar essas funções, o exemplo seguinte “passeia” por um diretório, exibe os nomes de todos os arquivos e chama a si mesmo recursivamente em todos os diretórios:</p>
<pre><code class="language-python">def walk(dirname):
    for name in os.listdir(dirname):
        path = os.path.join(dirname, name)
        if os.path.isfile(path):
            print(path)
        else:
            walk(path)
</code></pre>
<p><code>os.path.join</code> recebe um diretório e um nome de arquivo e os une em um caminho completo.</p>
<p>O módulo <code>os</code> fornece uma função chamada <code>walk</code>, que é semelhante, só que mais versátil. Como exercício, leia a documentação e use-a para exibir os nomes dos arquivos em um diretório dado e seus subdiretórios. Você pode baixar minha solução em http://thinkpython2.com/code/walk.py.</p>
<a class="header" href="14-arquivos.html#145---captura-de-exceções" id="145---captura-de-exceções"><h2>14.5 - Captura de exceções</h2></a>
<p>Muitas coisas podem dar errado quando você tenta ler e escrever arquivos. Se tentar abrir um arquivo que não existe, você recebe um <code>IOError</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; fin = open('bad_file')
IOError: [Errno 2] No such file or directory: 'bad\_file'
</code></pre>
<p>Se não tiver permissão para acessar um arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; fout = open('/etc/passwd', 'w')
PermissionError: [Errno 13] Permission denied: '/etc/passwd'
</code></pre>
<p>E se tentar abrir um diretório para leitura, recebe</p>
<pre><code class="language-python">&gt;&gt;&gt; fin = open('/home')
IsADirectoryError: [Errno 21] Is a directory: '/home'
</code></pre>
<p>Para evitar esses erros, você pode usar funções como <code>os.path.exists</code> e <code>os.path.isfile</code>, mas levaria muito tempo e código para verificar todas as possibilidades (se &quot;Errno 21&quot; significa algo, pode ser que pelo menos 21 coisas podem dar errado).</p>
<p>É melhor ir em frente e tentar, e lidar com problemas se eles surgirem, que é exatamente o que a instrução <code>try</code> faz. A sintaxe é semelhante à da instrução <code>if…else</code>:</p>
<pre><code class="language-python">try:
    fin = open('bad_file')
except:
    print('Something went wrong.')
</code></pre>
<p>O Python começa executando a cláusula <code>try</code>. Se tudo for bem, ele ignora a cláusula <code>except</code> e prossegue. Se ocorrer uma exceção, o programa sai da cláusula <code>try</code> e executa a cláusula <code>except</code>.</p>
<p>Lidar com exceções usando uma instrução <code>try</code> chama-se capturar uma exceção. Neste exemplo, a cláusula <code>except</code> exibe uma mensagem de erro que não é muito útil. Em geral, a captura de uma exceção oferece a oportunidade de corrigir o problema ou tentar novamente, ou, ao menos, de terminar o programa adequadamente.</p>
<a class="header" href="14-arquivos.html#146---bancos-de-dados" id="146---bancos-de-dados"><h2>14.6 - Bancos de dados</h2></a>
<p>Um banco de dados é um arquivo organizado para armazenar dados. Muitos bancos de dados são organizados como um dicionário, porque mapeiam chaves a valores. A maior diferença entre um banco de dados e um dicionário é que o banco de dados está em um disco (ou outro armazenamento permanente), portanto persiste depois que o programa termina.</p>
<p>O módulo dbm fornece uma interface para criar e atualizar arquivos de banco de dados. Como exemplo, criarei um banco de dados que contém legendas de arquivos de imagem.</p>
<p>Abrir um banco de dados é semelhante à abertura de outros arquivos:</p>
<pre><code class="language-python">&gt;&gt;&gt; import dbm
&gt;&gt;&gt; db = dbm.open('captions', 'c')
</code></pre>
<p>O modo 'c' significa que o banco de dados deve ser criado, se ainda não existir. O resultado é um objeto de banco de dados que pode ser usado (para a maior parte das operações) como um dicionário.</p>
<p>Quando você cria um novo item, dbm atualiza o arquivo de banco de dados:</p>
<pre><code class="language-python">&gt;&gt;&gt; db['cleese.png'] = 'Photo of John Cleese.'
</code></pre>
<p>Quando você acessa um dos itens, dbm lê o arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; db['cleese.png']
b'Photo of John Cleese.'
</code></pre>
<p>O resultado é um objeto <code>bytes</code>, o que explica o prefixo <code>b</code>. Um objeto <code>bytes</code> é semelhante a uma string, em muitos aspectos. Quando você avançar no Python, a diferença se tornará importante, mas, por enquanto, podemos ignorá-la.</p>
<p>Se fizer outra atribuição a uma chave existente, o dbm substitui o valor antigo:</p>
<pre><code class="language-python">&gt;&gt;&gt; db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'
&gt;&gt;&gt; db['cleese.png']
b'Photo of John Cleese doing a silly walk.'
</code></pre>
<p>Alguns métodos de dicionário, como keys e items, não funcionam com objetos de banco de dados. No entanto, a iteração com um loop <code>for</code>, sim:</p>
<pre><code class="language-python">for key in db:
    print(key, db[key])
</code></pre>
<p>Como em outros arquivos, você deve fechar o banco de dados quando terminar:</p>
<pre><code class="language-python">&gt;&gt;&gt; db.close()
</code></pre>
<a class="header" href="14-arquivos.html#147---usando-o-pickle" id="147---usando-o-pickle"><h2>14.7 - Usando o Pickle</h2></a>
<p>Uma limitação de <code>dbm</code> é que as chaves e os valores têm que ser strings ou bytes. Se tentar usar algum outro tipo, vai receber um erro.</p>
<p>O módulo <code>pickle</code> pode ajudar. Ele traduz quase qualquer tipo de objeto em uma string conveniente para o armazenamento em um banco de dados, e então traduz strings de volta em objetos.</p>
<p>pickle.dumps recebe um objeto como parâmetro e retorna uma representação de string:</p>
<pre><code class="language-python">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; t = [1, 2, 3]
&gt;&gt;&gt; pickle.dumps(t)
b'\x80\x03]q\x00(K\x01K\x02K\x03e.'
</code></pre>
<p>O formato não é óbvio para leitores humanos; o objetivo é que seja fácil para o <code>pickle</code> interpretar. <code>pickle.loads</code> reconstitui o objeto:</p>
<pre><code class="language-python">&gt;&gt;&gt; t1 = [1, 2, 3]
&gt;&gt;&gt; s = pickle.dumps(t1)
&gt;&gt;&gt; t2 = pickle.loads(s)
&gt;&gt;&gt; t2
[1, 2, 3]
</code></pre>
<p>Embora o novo objeto tenha o mesmo valor que o antigo, não é (em geral) o mesmo objeto:</p>
<pre><code class="language-python">&gt;&gt;&gt; t1 == t2
True
&gt;&gt;&gt; t1 is t2
False
</code></pre>
<p>Em outras palavras, usar o <code>pickle.dumps</code> e <code>pickle.loads</code> tem o mesmo efeito que copiar o objeto.</p>
<p>Você pode usar o <code>pickle</code> para guardar variáveis que não são strings em um banco de dados. Na verdade, esta combinação é tão comum que foi encapsulada em um módulo chamado <code>shelve</code>.</p>
<a class="header" href="14-arquivos.html#148---pipes" id="148---pipes"><h2>14.8 - Pipes</h2></a>
<p>A maior parte dos sistemas operacionais fornece uma interface de linha de comando, conhecida como shell. Shells normalmente fornecem comandos para navegar nos sistemas de arquivos e executar programas. Por exemplo, em Unix você pode alterar diretórios com <code>cd</code>, exibir o conteúdo de um diretório com <code>ls</code> e abrir um navegador web digitando (por exemplo) <code>firefox</code>.</p>
<p>Qualquer programa que possa ser aberto no shell também pode ser aberto no Python usando um objeto pipe, que representa um programa em execução.</p>
<p>Por exemplo, o comando Unix <code>ls -l</code> normalmente exibe o conteúdo do diretório atual no formato longo. Você pode abrir ls com <code>os.popen[1]</code>:</p>
<pre><code class="language-python">&gt;&gt;&gt; cmd = 'ls -l'
&gt;&gt;&gt; fp = os.popen(cmd)
</code></pre>
<p>O argumento é uma string que contém um comando shell. O valor de retorno é um objeto que se comporta como um arquivo aberto. É possível ler a saída do processo ls uma linha por vez com readline ou receber tudo de uma vez com read:</p>
<pre><code class="language-python">&gt;&gt;&gt; res = fp.read()
</code></pre>
<p>Ao terminar, feche o pipe como se fosse um arquivo:</p>
<pre><code class="language-python">&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print(stat)
None
</code></pre>
<p>O valor de retorno é o status final do processo <code>ls</code>; <code>None</code> significa que terminou normalmente (sem erros).</p>
<p>Por exemplo, a maior parte dos sistemas Unix oferece um comando chamado <code>md5sum</code>, que lê o conteúdo de um arquivo e calcula uma assinatura digital. Você pode ler sobre o MD5 em http://en.wikipedia.org/wiki/Md5. Este comando fornece uma forma eficiente de verificar se dois arquivos têm o mesmo conteúdo. A probabilidade de dois conteúdos diferentes produzirem a mesma assinatura digital é muito pequena (isto é, muito pouco provável que aconteça antes do colapso do universo).</p>
<p>Você pode usar um pipe para executar o <code>md5sum</code> do Python e receber o resultado:</p>
<pre><code class="language-python">&gt;&gt;&gt; filename = 'book.tex'
&gt;&gt;&gt; cmd = 'md5sum ' + filename
&gt;&gt;&gt; fp = os.popen(cmd)
&gt;&gt;&gt; res = fp.read()
&gt;&gt;&gt; stat = fp.close()
&gt;&gt;&gt; print(res)
1e0033f0ed0656636de0d75144ba32e0 book.tex
&gt;&gt;&gt; print(stat)
None
</code></pre>
<a class="header" href="14-arquivos.html#149---escrevendo-módulos" id="149---escrevendo-módulos"><h2>14.9 - Escrevendo módulos</h2></a>
<p>Qualquer arquivo que contenha código do Python pode ser importado como um módulo. Por exemplo, vamos supor que você tenha um arquivo chamado <code>wc.py</code> com o seguinte código:</p>
<pre><code class="language-python">def linecount(filename):
    count = 0
    for line in open(filename):
        count += 1
    return count

print(linecount('wc.py'))
</code></pre>
<p>Quando este programa é executado, ele lê a si mesmo e exibe o número de linhas no arquivo, que é 7. Você também pode importá-lo desta forma:</p>
<pre><code class="language-python">&gt;&gt;&gt; import wc
7
</code></pre>
<p>Agora você tem um objeto de módulo wc:</p>
<pre><code class="language-python">&gt;&gt;&gt; wc
&lt;module 'wc' from 'wc.py'&gt;
</code></pre>
<p>O objeto de módulo fornece o linecount:</p>
<pre><code class="language-python">&gt;&gt;&gt; wc.linecount('wc.py')
7
</code></pre>
<p>Então é assim que se escreve módulos no Python.</p>
<p>O único problema com este exemplo é que quando você importa o módulo, ele executa o código de teste no final. Normalmente, quando se importa um módulo, ele define novas funções, mas não as executa.</p>
<p>Os programas que serão importados como módulos muitas vezes usam a seguinte expressão:</p>
<pre><code class="language-python">if __name__ == '__main__':
    print(linecount('wc.py'))
</code></pre>
<p><code>__name__</code> é uma variável integrada, estabelecida quando o programa inicia. Se o programa estiver rodando como um script, <code>__name__</code> tem o valor <code>'__main__'</code>; neste caso, o código de teste é executado. Do contrário, se o módulo está sendo importado, o código de teste é ignorado.</p>
<p>Como exercício, digite este exemplo em um arquivo chamado wc.py e execute-o como um script. Então execute o interpretador do Python e import wc. Qual é o valor de <code>__name__</code> quando o módulo está sendo importado?</p>
<p>Atenção: se você importar um módulo que já tenha sido importado, o Python não faz nada. Ele não relê o arquivo, mesmo se tiver sido alterado.</p>
<p>Se quiser recarregar um módulo, você pode usar a função integrada <code>reload</code>, mas isso pode causar problemas, então o mais seguro é reiniciar o interpretador e importar o módulo novamente.</p>
<a class="header" href="14-arquivos.html#1410---depuração" id="1410---depuração"><h2>14.10 - Depuração</h2></a>
<p>Quando estiver lendo e escrevendo arquivos, você pode ter problemas com whitespace. Esses erros podem ser difíceis para depurar, porque os espaços, tabulações e quebras de linha normalmente são invisíveis:</p>
<pre><code class="language-python">&gt;&gt;&gt; s = '1 2\t 3\n 4'
&gt;&gt;&gt; print(s)
1 2      3
 4
</code></pre>
<p>A função integrada <code>repr</code> pode ajudar. Ela recebe qualquer objeto como argumento e retorna uma representação em string do objeto. Para strings, representa caracteres de whitespace com sequências de barras invertidas:</p>
<pre><code class="language-python">&gt;&gt;&gt; print(repr(s))
'1 2\t 3\n 4'
</code></pre>
<p>Isso pode ser útil para a depuração.</p>
<p>Outro problema que você pode ter é que sistemas diferentes usam caracteres diferentes para indicar o fim de uma linha. Alguns sistemas usam newline, representado por <code>\n</code>. Outros usam um caractere de retorno, representado por <code>\r</code>. Alguns usam ambos. Se mover arquivos entre sistemas diferentes, essas inconsistências podem causar problemas.</p>
<p>Para a maior parte dos sistemas há aplicações para converter de um formato a outro. Você pode encontrá-los (e ler mais sobre o assunto) em http://en.wikipedia.org/wiki/Newline. Ou, é claro, você pode escrever um por conta própria.</p>
<a class="header" href="14-arquivos.html#1411---glossário" id="1411---glossário"><h2>14.11 - Glossário</h2></a>
<dl>
<dt><a id="glos:persistente" href="14-arquivos.html#termo:persistente">persistente</a></dt>
<dd>Relativo a um programa que roda indefinidamente e mantém pelo menos alguns dos seus dados em armazenamento permanente.</dd>
<dt><a id="glos:operador de formatação" href="14-arquivos.html#termo:operador de formatação">operador de formatação</a></dt>
<dd>Um operador, %, que recebe uma string de formatação e uma tupla e gera uma string que inclui os elementos da tupla formatada como especificado pela string de formatação.</dd>
<dt><a id="glos:string de formatação" href="14-arquivos.html#termo:string de formatação">string de formatação</a></dt>
<dd>String usada com o operador de formatação, que contém sequências de formatação.</dd>
<dt><a id="glos:sequência de formatação" href="14-arquivos.html#termo:sequência de formatação">sequência de formatação</a></dt>
<dd>Sequência de caracteres em uma string de formatação, como %d, que especifica como um valor deve ser formatado.</dd>
<dt><a id="glos:arquivo de texto" href="14-arquivos.html#termo:arquivo de texto">arquivo de texto</a></dt>
<dd>Sequência de caracteres guardados em armazenamento permanente, como uma unidade de disco rígido.</dd>
<dt><a id="glos:diretório" href="14-arquivos.html#termo:diretório">diretório</a></dt>
<dd>Uma coleção de arquivos nomeada, também chamada de pasta.</dd>
<dt><a id="glos:caminho" href="14-arquivos.html#termo:caminho">caminho</a></dt>
<dd>String que identifica um arquivo.</dd>
<dt><a id="glos:caminho relativo" href="14-arquivos.html#termo:caminho relativo">caminho relativo</a></dt>
<dd>Caminho que inicia no diretório atual.</dd>
<dt><a id="glos:caminho absoluto" href="14-arquivos.html#termo:caminho absoluto">caminho absoluto</a></dt>
<dd>Caminho que inicia no diretório de posição mais alta (raiz) no sistema de arquivos.</dd>
<dt><a id="glos:capturar" href="14-arquivos.html#termo:capturar">capturar</a></dt>
<dd>Impedir uma exceção de encerrar um programa usando as instruções try e except.</dd>
<dt><a id="glos:banco de dados" href="14-arquivos.html#termo:banco de dados">banco de dados</a></dt>
<dd>Um arquivo cujo conteúdo é organizado como um dicionário, com chaves que correspondem a valores.</dd>
<dt><a id="glos:objeto bytes" href="14-arquivos.html#termo:objeto bytes">objeto bytes</a></dt>
<dd>Objeto semelhante a uma string.</dd>
<dt><a id="glos:shell" href="14-arquivos.html#termo:shell">shell</a></dt>
<dd>Programa que permite aos usuários digitar comandos e executá-los para iniciar outros programas.</dd>
<dt><a id="glos:objeto pipe" href="14-arquivos.html#termo:objeto pipe">objeto pipe</a></dt>
<dd>Objeto que representa um programa em execução, permitindo que um programa do Python execute comandos e leia os resultados.</dd>
</dl>
<a class="header" href="14-arquivos.html#1412---exercícios" id="1412---exercícios"><h2>14.12 - Exercícios</h2></a>
<a class="header" href="14-arquivos.html#exercício-141" id="exercício-141"><h3>Exercício 14.1</h3></a>
<p>Escreva uma função chamada sed que receba como argumentos uma string-padrão, uma string de substituição e dois nomes de arquivo; ela deve ler o primeiro arquivo e escrever o conteúdo no segundo arquivo (criando-o, se necessário). Se a string-padrão aparecer em algum lugar do arquivo, ela deve ser substituída pela string de substituição.</p>
<p>Se ocorrer um erro durante a abertura, leitura, escrita ou fechamento dos arquivos, seu programa deve capturar a exceção, exibir uma mensagem de erro e encerrar.</p>
<p>Solução: http://thinkpython2.com/code/sed.py.</p>
<a class="header" href="14-arquivos.html#exercício-142" id="exercício-142"><h3>Exercício 14.2</h3></a>
<p>Se você baixar minha solução do Exercício 12.2 em http://thinkpython2.com/code/anagram_sets.py, verá que ela cria um dicionário que mapeia uma string ordenada de letras à lista de palavras que podem ser soletradas com aquelas letras. Por exemplo, <code>'opst'</code> mapeia à lista <code>['opts', 'post', 'pots', 'spot', 'stop', 'tops']</code>.</p>
<p>Escreva um módulo que importe <code>anagram_sets</code> e forneça duas novas funções: <code>store_anagrams</code> deve guardar o dicionário de anagramas em uma “prateleira” (objeto criado pelo módulo <code>sheve</code>); <code>read_anagrams</code> deve procurar uma palavra e devolver uma lista dos seus anagramas.</p>
<p>Solução: http://thinkpython2.com/code/anagram_db.py.</p>
<a class="header" href="14-arquivos.html#exercício-143" id="exercício-143"><h3>Exercício 14.3</h3></a>
<p>Em uma grande coleção de arquivos MP3 pode haver mais de uma cópia da mesma música, guardada em diretórios diferentes ou com nomes de arquivo diferentes. A meta deste exercício é procurar duplicatas.</p>
<ol>
<li>
<p>Escreva um programa que procure um diretório e todos os seus subdiretórios, recursivamente, e retorne uma lista de caminhos completos de todos os arquivos com um dado sufixo (como .mp3). Dica: os.path fornece várias funções úteis para manipular nomes de caminhos e de arquivos.</p>
</li>
<li>
<p>Para reconhecer duplicatas, você pode usar md5sum para calcular uma “soma de controle” para cada arquivo. Se dois arquivos tiverem a mesma soma de controle, provavelmente têm o mesmo conteúdo.</p>
</li>
<li>
<p>Para conferir o resultado, você pode usar o comando Unix <code>diff</code>.</p>
</li>
</ol>
<p>Solução: http://thinkpython2.com/code/find_duplicates.py.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="13-caso-estruturas.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="15-classes-objetos.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="13-caso-estruturas.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="15-classes-objetos.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
