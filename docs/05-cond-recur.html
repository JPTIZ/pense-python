<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Condicionais e recursividade - Pense em Python</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Pense como um cientista da computação">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="introducao.html">Pense em Python</a></li><li class="affix"><a href="00-prefacio.html">Prefácio</a></li><li><a href="01-jornada.html"><strong aria-hidden="true">1.</strong> A jornada do programa</a></li><li><a href="02-vars-expr-instr.html"><strong aria-hidden="true">2.</strong> Variáveis, expressões e instruções</a></li><li><a href="03-funcoes.html"><strong aria-hidden="true">3.</strong> Funções</a></li><li><a href="04-caso-interface.html"><strong aria-hidden="true">4.</strong> Estudo de caso: projeto de interface</a></li><li><a href="05-cond-recur.html" class="active"><strong aria-hidden="true">5.</strong> Condicionais e recursividade</a></li><li><a href="06-funcoes-result.html"><strong aria-hidden="true">6.</strong> Funções com resultado</a></li><li><a href="07-iteracao.html"><strong aria-hidden="true">7.</strong> Iteração</a></li><li><a href="08-strings.html"><strong aria-hidden="true">8.</strong> Strings</a></li><li><a href="09-caso-palavras.html"><strong aria-hidden="true">9.</strong> Estudo de caso: jogos de palavras</a></li><li><a href="10-listas.html"><strong aria-hidden="true">10.</strong> Listas</a></li><li><a href="11-dicionarios.html"><strong aria-hidden="true">11.</strong> Dicionários</a></li><li><a href="12-tuplas.html"><strong aria-hidden="true">12.</strong> Tuplas</a></li><li><a href="13-caso-estruturas.html"><strong aria-hidden="true">13.</strong> Estudo de caso: seleção de estrutura de dados</a></li><li><a href="14-arquivos.html"><strong aria-hidden="true">14.</strong> Arquivos</a></li><li><a href="15-classes-objetos.html"><strong aria-hidden="true">15.</strong> Classes e objetos</a></li><li><a href="16-classes-funcoes.html"><strong aria-hidden="true">16.</strong> Classes e funções</a></li><li><a href="17-classes-metodos.html"><strong aria-hidden="true">17.</strong> Classes e métodos</a></li><li><a href="18-heranca.html"><strong aria-hidden="true">18.</strong> Herança</a></li><li><a href="19-extra.html"><strong aria-hidden="true">19.</strong> Extra</a></li><li class="affix"><a href="A-depuracao.html">Apêndice A: Depuração</a></li><li class="affix"><a href="B-analise-algorit.html">Apêndice B: Análise de algoritmos</a></li><li class="affix"><a href="C-colofao-autor.html">Colofão / Sobre o Autor</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Pense em Python</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="05-cond-recur.html#capítulo-5-condicionais-e-recursividade" id="capítulo-5-condicionais-e-recursividade"><h1>Capítulo 5: Condicionais e recursividade</h1></a>
<p>O tópico principal deste capítulo é a instrução if, que executa códigos diferentes dependendo do estado do programa. Mas primeiro quero apresentar dois novos operadores: divisão pelo piso e módulo.</p>
<a class="header" href="05-cond-recur.html#51---divisão-pelo-piso-e-módulo" id="51---divisão-pelo-piso-e-módulo"><h2>5.1 - Divisão pelo piso e módulo</h2></a>
<p>O operador de divisão pelo piso, //, divide dois números e arredonda o resultado para um número inteiro para baixo. Por exemplo, suponha que o tempo de execução de um filme seja de 105 minutos. Você pode querer saber a quanto isso corresponde em horas. A divisão convencional devolve um número de ponto flutuante:</p>
<pre><code class="language-python">&gt;&gt;&gt; minutes = 105
&gt;&gt;&gt; minutes / 60
1.75
</code></pre>
<p>Mas não é comum escrever horas com pontos decimais. A divisão pelo piso devolve o número inteiro de horas, ignorando a parte fracionária:</p>
<pre><code class="language-python">&gt;&gt;&gt; minutes = 105
&gt;&gt;&gt; hours = minutes // 60
&gt;&gt;&gt; hours
1
</code></pre>
<p>Para obter o resto, você pode subtrair uma hora em minutos:</p>
<pre><code class="language-python">&gt;&gt;&gt; remainder = minutes - hours * 60
&gt;&gt;&gt; remainder
45
</code></pre>
<p>Uma alternativa é usar o operador módulo, %, que divide dois números e devolve o resto:</p>
<pre><code class="language-python">&gt;&gt;&gt; remainder = minutes % 60
&gt;&gt;&gt; remainder
45
</code></pre>
<p>O operador módulo é mais útil do que parece. Por exemplo, é possível verificar se um número é divisível por outro – se x % y for zero, então x é divisível por y.</p>
<p>Além disso, você pode extrair o dígito ou dígitos mais à direita de um número. Por exemplo, x % 10 produz o dígito mais à direita de x (na base 10). Da mesma forma x % 100 produz os dois últimos dígitos.</p>
<p>Se estiver usando o Python 2, a divisão funciona de forma diferente. O operador de divisão, /, executa a divisão pelo piso se ambos os operandos forem números inteiros e faz a divisão de ponto flutuante se pelo menos um dos operandos for do tipo float.</p>
<a class="header" href="05-cond-recur.html#52---expressões-booleanas" id="52---expressões-booleanas"><h2>5.2 - Expressões booleanas</h2></a>
<p>Uma expressão booleana é uma expressão que pode ser verdadeira ou falsa. Os exemplos seguintes usam o operador ==, que compara dois operandos e produz True se forem iguais e False se não forem:</p>
<pre><code class="language-python">&gt;&gt;&gt; 5 == 5
True
&gt;&gt;&gt; 5 == 6
False
</code></pre>
<p>True e False são valores especiais que pertencem ao tipo bool; não são strings:</p>
<pre><code class="language-python">&gt;&gt;&gt; type(True)
&lt;class 'bool'&gt;
&gt;&gt;&gt; type(False)
&lt;class 'bool'&gt;
</code></pre>
<p>O operador == é um dos operadores relacionais; os outros são:</p>
<pre><code class="language-python">x != y                # x não é igual a y
x &gt; y                 # x é maior que y
x &lt; y                 # x é menor que y
x &gt;= y                # x é maior ou igual a y
x &lt;= y                # x é menor ou igual a y
</code></pre>
<p>Embora essas operações provavelmente sejam familiares para você, os símbolos do Python são diferentes dos símbolos matemáticos. Um erro comum é usar apenas um sinal de igual (=) em vez de um sinal duplo (==). Lembre-se de que = é um operador de atribuição e == é um operador relacional. Não existe =&lt; ou =&gt;.</p>
<a class="header" href="05-cond-recur.html#53---operadores-lógicos" id="53---operadores-lógicos"><h2>5.3 - Operadores lógicos</h2></a>
<p>Há três operadores lógicos: and, or e not. A semântica (significado) destes operadores é semelhante ao seu significado em inglês. Por exemplo, x&gt; 0 and x &lt;10 só é verdade se x for maior que 0 e menor que 10.</p>
<p>n%2 == 0 or n%3 == 0 é verdadeiro se uma ou as duas condição(ões) for(em) verdadeira(s), isto é, se o número for divisível por 2 ou 3.</p>
<p>Finalmente, o operador not nega uma expressão booleana, então not (x &gt; y) é verdade se x &gt; y for falso, isto é, se x for menor que ou igual a y.</p>
<p>Falando estritamente, os operandos dos operadores lógicos devem ser expressões booleanas, mas o Python não é muito estrito. Qualquer número que não seja zero é interpretado como True:</p>
<pre><code class="language-python">&gt;&gt;&gt; 42 and True
True
</code></pre>
<p>Esta flexibilidade tem sua utilidade, mas há algumas sutilezas relativas a ela que podem ser confusas. Assim, pode ser uma boa ideia evitá-la (a menos que saiba o que está fazendo).</p>
<a class="header" href="05-cond-recur.html#54---execução-condicional" id="54---execução-condicional"><h2>5.4 - Execução condicional</h2></a>
<p>Para escrever programas úteis, quase sempre precisamos da capacidade de verificar condições e mudar o comportamento do programa de acordo com elas. Instruções condicionais nos dão esta capacidade. A forma mais simples é a instrução if:</p>
<pre><code class="language-python">if x &gt; 0:
    print('x is positive')
</code></pre>
<p>A expressão booleana depois do if é chamada de condição. Se for verdadeira, a instrução endentada é executada. Se não, nada acontece.</p>
<p>Instruções if têm a mesma estrutura que definições de função: um cabeçalho seguido de um corpo endentado. Instruções como essa são chamadas de instruções compostas.</p>
<p>Não há limite para o número de instruções que podem aparecer no corpo, mas deve haver pelo menos uma. Ocasionalmente, é útil ter um corpo sem instruções (normalmente como um espaço reservado para código que ainda não foi escrito). Neste caso, você pode usar a instrução pass, que não faz nada.</p>
<pre><code class="language-python">if x &lt; 0:
    pass          # A FAZER: lidar com valores negativos!
</code></pre>
<a class="header" href="05-cond-recur.html#55---execução-alternativa" id="55---execução-alternativa"><h2>5.5 - Execução alternativa</h2></a>
<p>Uma segunda forma da instrução if é a “execução alternativa”, na qual há duas possibilidades e a condição determina qual será executada. A sintaxe pode ser algo assim:</p>
<pre><code class="language-python">if x % 2 == 0:
    print('x is even')
else:
    print('x is odd')
</code></pre>
<p>Se o resto quando x for dividido por 2 for 0, então sabemos que x é par e o programa exibe uma mensagem adequada. Se a condição for falsa, o segundo conjunto de instruções é executado. Como a condição deve ser verdadeira ou falsa, exatamente uma das alternativas será executada. As alternativas são chamadas de ramos (branches), porque são ramos no fluxo da execução.</p>
<a class="header" href="05-cond-recur.html#56---condicionais-encadeadas" id="56---condicionais-encadeadas"><h2>5.6 - Condicionais encadeadas</h2></a>
<p>Às vezes, há mais de duas possibilidades e precisamos de mais que dois ramos. Esta forma de expressar uma operação de computação é uma condicional encadeada:</p>
<pre><code class="language-python">if x &lt; y:
    print('x is less than y')
elif x &gt; y:
    print('x is greater than y')
else:
    print('x and y are equal')
</code></pre>
<p>elif é uma abreviatura de “else if”. Novamente, exatamente um ramo será executado. Não há nenhum limite para o número de instruções elif. Se houver uma cláusula else, ela deve estar no fim, mas não é preciso haver uma.</p>
<pre><code class="language-python">if choice == 'a':
    draw_a()
elif choice == 'b':
    draw_b()
elif choice == 'c':
    draw_c()
</code></pre>
<p>Cada condição é verificada em ordem. Se a primeira for falsa, a próxima é verificada, e assim por diante. Se uma delas for verdadeira, o ramo correspondente é executado e a instrução é encerrada. Mesmo se mais de uma condição for verdade, só o primeiro ramo verdadeiro é executado.</p>
<a class="header" href="05-cond-recur.html#57---condicionais-aninhadas" id="57---condicionais-aninhadas"><h2>5.7 - Condicionais aninhadas</h2></a>
<p>Uma condicional também pode ser aninhada dentro de outra. Poderíamos ter escrito o exemplo na seção anterior desta forma:</p>
<pre><code class="language-python">if x == y:
    print('x and y are equal')
else:
    if x &lt; y:
        print('x is less than y')
    else:
        print('x is greater than y')
</code></pre>
<p>A condicional exterior contém dois ramos. O primeiro ramo contém uma instrução simples. O segundo ramo contém outra instrução if, que tem outros dois ramos próprios. Esses dois ramos são instruções simples, embora pudessem ser instruções condicionais também.</p>
<p>Embora a endentação das instruções evidencie a estrutura das condicionais, condicionais aninhadas são difíceis de ler rapidamente. É uma boa ideia evitá-las quando for possível.</p>
<p>Operadores lógicos muitas vezes oferecem uma forma de simplificar instruções condicionais aninhadas. Por exemplo, podemos reescrever o seguinte código usando uma única condicional:</p>
<pre><code class="language-python">if 0 &lt; x:
    if x &lt; 10:
        print('x is a positive single-digit number.')
</code></pre>
<p>A instrução print só é executada se a colocarmos depois de ambas as condicionais, então podemos obter o mesmo efeito com o operador and:</p>
<pre><code class="language-python">if 0 &lt; x and x &lt; 10:
    print('x is a positive single-digit number.')
</code></pre>
<p>Para este tipo de condição, o Python oferece uma opção mais concisa:</p>
<pre><code class="language-python">if 0 &lt; x &lt; 10:
    print('x is a positive single-digit number.')
</code></pre>
<a class="header" href="05-cond-recur.html#58---recursividade" id="58---recursividade"><h2>5.8 - Recursividade</h2></a>
<p>É legal para uma função chamar outra; também é legal para uma função chamar a si própria. Pode não ser óbvio porque isso é uma coisa boa, mas na verdade é uma das coisas mais mágicas que um programa pode fazer. Por exemplo, veja a seguinte função:</p>
<pre><code class="language-python">def countdown(n):
    if n &lt;= 0:
        print('Blastoff!')
    else:
        print(n)
        countdown(n-1)
</code></pre>
<p>Se n for 0 ou negativo, a palavra “Blastoff!” é exibida, senão a saída é n e então a função countdown é chamada – por si mesma – passando n-1 como argumento.</p>
<p>O que acontece se chamarmos esta função assim?</p>
<pre><code class="language-python">&gt;&gt;&gt; countdown(3)
</code></pre>
<p>A execução de countdown inicia com n=3 e como n é maior que 0, ela produz o valor 3 e então chama a si mesma...</p>
<p>    A execução de countdown inicia com n=2 e como n é maior que 0, ela produz o valor 2 e então chama a si mesma...</p>
<p>        A execução de countdown inicia com n=1 e como n é maior que 0, ela produz o valor 1 e então chama a si mesma...</p>
<p>            A execução de countdown inicia com n=0 e como n não é maior que 0, ela produz a palavra “Blastoff!” e então retorna.</p>
<p>        O countdown que recebeu n=1 retorna.</p>
<p>    O countdown que recebeu n=2 retorna.</p>
<p>O countdown que recebeu n=3 retorna.</p>
<p>E então você está de volta ao <code>__main__</code>. Então a saída completa será assim:</p>
<pre><code class="language-python">3
2
1
Blastoff!
</code></pre>
<p>Uma função que chama a si mesma é dita recursiva; o processo para executá-la é a recursividade.</p>
<p>Como em outro exemplo, podemos escrever uma função que exiba uma string n vezes:</p>
<pre><code class="language-python">def print_n(s, n):
    if n &lt;= 0:
        return
    print(s)
    print_n(s, n-1)
</code></pre>
<p>Se <code>n &lt;= 0</code> a instrução <code>return</code> causa a saída da função. O fluxo de execução volta imediatamente a quem fez a chamada, e as linhas restantes da função não são executadas.</p>
<p>O resto da função é similar à countdown: ela mostra s e então chama a si mesma para mostrar s mais n-1 vezes. Então o número de linhas da saída é 1 + (n - 1), até chegar a n.</p>
<p>Para exemplos simples como esse, provavelmente é mais fácil usar um loop for. Mais adiante veremos exemplos que são difíceis de escrever com um loop for e fáceis de escrever com recursividade, então é bom começar cedo.</p>
<a class="header" href="05-cond-recur.html#59---diagramas-da-pilha-para-funções-recursivas" id="59---diagramas-da-pilha-para-funções-recursivas"><h2>5.9 - Diagramas da pilha para funções recursivas</h2></a>
<p>Em “Diagrama da pilha”, na página 55, usamos um diagrama da pilha para representar o estado de um programa durante uma chamada de função. O mesmo tipo de diagrama pode ajudar a interpretar uma função recursiva.</p>
<p>Cada vez que uma função é chamada, o Python cria um frame para conter as variáveis locais e parâmetros da função. Para uma função recursiva, pode haver mais de um frame na pilha ao mesmo tempo.</p>
<p>A Figura 5.1 mostra um diagrama da pilha para <code>countdown</code> chamado com n = 3.</p>
<p><img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_0501.png" alt="Figura 5.1 – Diagrama da pilha." />
<br><em>Figura 5.1 – Diagrama da pilha.</em></p>
<p>Como de hábito, o topo da pilha é o frame de <code>__main__</code>. Está vazio porque não criamos nenhuma variável em <code>__main__</code> nem passamos argumentos a ela.</p>
<p>Os quatro frames do countdown têm valores diferentes para o parâmetro <code>n</code>. O fundo da pilha, onde <code>n = 0</code>, é chamado caso-base. Ele não faz uma chamada recursiva, então não há mais frames.</p>
<p>Como exercício, desenhe um diagrama da pilha para <code>print_n</code> chamado com <code>s = 'Hello'</code> e <code>n = 2</code>. Então escreva uma função chamada <code>do_n</code> que tome um objeto de função e um número <code>n</code> como argumentos e que chame a respectiva função <code>n</code> vezes.</p>
<a class="header" href="05-cond-recur.html#510---recursividade-infinita" id="510---recursividade-infinita"><h2>5.10 - Recursividade infinita</h2></a>
<p>Se a recursividade nunca atingir um caso-base, continua fazendo chamadas recursivas para sempre, e o programa nunca termina. Isso é conhecido como recursividade infinita e geralmente não é uma boa ideia. Aqui está um programa mínimo com recursividade infinita:</p>
<pre><code class="language-python">def recurse():
    recurse()
</code></pre>
<p>Na maior parte dos ambientes de programação, um programa com recursividade infinita não é realmente executado para sempre. O Python exibe uma mensagem de erro quando a profundidade máxima de recursividade é atingida:</p>
<pre><code class="language-python">  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
                  .
                  .
                  .
  File &quot;&lt;stdin&gt;&quot;, line 2, in recurse
RuntimeError: Maximum recursion depth exceeded
</code></pre>
<p>Este traceback é um pouco maior que o que vimos no capítulo anterior. Quando o erro ocorre, há mil frames de recurse na pilha!</p>
<p>Se você escrever em recursividade infinita por engano, confira se a sua função tem um caso-base que não faz uma chamada recursiva. E se houver um caso-base, verifique se você vai mesmo atingi-lo.</p>
<a class="header" href="05-cond-recur.html#511---entrada-de-teclado" id="511---entrada-de-teclado"><h2>5.11 - Entrada de teclado</h2></a>
<p>Os programas que escrevemos até agora não aceitam entradas do usuário. Eles sempre fazem a mesma coisa cada vez.</p>
<p>O Python fornece uma função integrada chamada <code>input</code> que interrompe o programa e espera que o usuário digite algo. Quando o usuário pressionar Return ou Enter, o programa volta a ser executado e input retorna o que o usuário digitou como uma string. No Python 2, a mesma função é chamada <code>raw_input</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; text = input()
What are you waiting for?
&gt;&gt;&gt; text
What are you waiting for?
</code></pre>
<p>Antes de receber entradas do usuário, é uma boa ideia exibir um prompt dizendo ao usuário o que ele deve digitar. input pode ter um prompt como argumento:</p>
<pre><code class="language-python">&gt;&gt;&gt; name = input('What...is your name?\\n')
What...is your name?
Arthur, King of the Britons!
&gt;&gt;&gt; name
Arthur, King of the Britons!
</code></pre>
<p>A sequência <code>\n</code> no final do prompt representa um newline, que é um caractere especial de quebra de linha. É por isso que a entrada do usuário aparece abaixo do prompt.</p>
<p>Se esperar que o usuário digite um número inteiro, você pode tentar converter o valor de retorno para int:</p>
<pre><code class="language-python">&gt;&gt;&gt; prompt = 'What...is the airspeed velocity of an unladen swallow?\\n'
&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
42
&gt;&gt;&gt; int(speed)
42
</code></pre>
<p>Mas se o usuário digitar algo além de uma série de dígitos, você recebe um erro:</p>
<pre><code class="language-python">&gt;&gt;&gt; speed = input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
&gt;&gt;&gt; int(speed)
ValueError: invalid literal for int() with base 10
</code></pre>
<p>Veremos como tratar este tipo de erro mais adiante.</p>
<a class="header" href="05-cond-recur.html#512---depuração" id="512---depuração"><h2>5.12 - Depuração</h2></a>
<p>Quando um erro de sintaxe ou de tempo de execução ocorre, a mensagem de erro contém muita informação, às vezes, até demais. As partes mais úteis são normalmente:</p>
<ul>
<li>
<p>que tipo de erro foi;</p>
</li>
<li>
<p>onde ocorreu.</p>
</li>
</ul>
<p>Erros de sintaxe são normalmente fáceis de encontrar, mas há algumas pegadinhas. Erros de whitespace podem ser complicados porque os espaços e tabulações são invisíveis e estamos acostumados a ignorá-los.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 5
&gt;&gt;&gt; y = 6
  File &quot;&lt;stdin&gt;&quot;, line 1
    y = 6
    ^
IndentationError: unexpected indent
</code></pre>
<p>Neste exemplo, o problema é que a segunda linha está endentada por um espaço. Mas a mensagem de erro aponta para y, o que pode ser capcioso. Em geral, mensagens de erro indicam onde o problema foi descoberto, mas o erro real pode estar em outra parte do código, às vezes, em uma linha anterior.</p>
<p>O mesmo acontece com erros em tempo de execução. Suponha que você esteja tentando calcular a proporção de sinal a ruído em decibéis. A fórmula é SNRdb = 10 log10 (Psignal/Pnoise). No Python, você poderia escrever algo assim:</p>
<pre><code class="language-python">import math
signal_power = 9
noise_power = 10
ratio = signal_power // noise_power
decibels = 10 * math.log10(ratio)
print(decibels)
</code></pre>
<p>Ao executar este programa, você recebe uma exceção:</p>
<pre><code class="language-python">Traceback (most recent call last):
  File &quot;snr.py&quot;, line 5, in ?
    decibels = 10 * math.log10(ratio)
ValueError: math domain error
</code></pre>
<p>A mensagem de erro indica a linha 5, mas não há nada de errado com esta linha. Uma opção para encontrar o verdadeiro erro é exibir o valor de ratio, que acaba sendo 0. O problema está na linha 4, que usa a divisão pelo piso em vez da divisão de ponto flutuante.</p>
<p>É preciso ler as mensagens de erro com atenção, mas não assumir que tudo que dizem esteja correto.</p>
<a class="header" href="05-cond-recur.html#513---glossário" id="513---glossário"><h2>5.13 - Glossário</h2></a>
<dl>
<dt><a id="glos:divisão pelo piso" href="05-cond-recur.html#termo:divisão pelo piso">divisão pelo piso</a></dt>
<dd>Um operador, denotado por //, que divide dois números e arredonda o resultado para baixo (em direção ao zero), a um número inteiro.</dd>
<dt><a id="glos:operador módulo" href="05-cond-recur.html#termo:operador módulo">operador módulo</a></dt>
<dd>Um operador, denotado com um sinal de percentagem (%), que funciona com números inteiros e devolve o resto quando um número é dividido por outro.</dd>
<dt><a id="glos:expressão booleana" href="05-cond-recur.html#termo:expressão booleana">expressão booleana</a></dt>
<dd>Uma expressão cujo valor é True (verdadeiro) ou False (falso).</dd>
<dt><a id="glos:operador relacional" href="05-cond-recur.html#termo:operador relacional">operador relacional</a></dt>
<dd>Um destes operadores, que compara seus operandos: `==`, `!=`, `>`, `<`, `>=` e `<=`.</dd>
<dt><a id="glos:operador lógico" href="05-cond-recur.html#termo:operador lógico">operador lógico</a></dt>
<dd>Um destes operadores, que combina expressões booleanas: and (e), or (ou) e not (não).</dd>
<dt><a id="glos:instrução condicional" href="05-cond-recur.html#termo:instrução condicional">instrução condicional</a></dt>
<dd>Uma instrução que controla o fluxo de execução, dependendo de alguma condição.</dd>
<dt><a id="glos:condição" href="05-cond-recur.html#termo:condição">condição</a></dt>
<dd>A expressão booleana em uma instrução condicional que determina qual ramo deve ser executado.</dd>
<dt><a id="glos:instrução composta" href="05-cond-recur.html#termo:instrução composta">instrução composta</a></dt>
<dd>Uma instrução composta de um cabeçalho e um corpo. O cabeçalho termina em dois pontos (:). O corpo é endentado em relação ao cabeçalho.</dd>
<dt><a id="glos:ramo" href="05-cond-recur.html#termo:ramo">ramo</a></dt>
<dd>Uma das sequências alternativas de instruções em uma instrução condicional.</dd>
<dt><a id="glos:condicional encadeada" href="05-cond-recur.html#termo:condicional encadeada">condicional encadeada</a></dt>
<dd>Uma instrução condicional com uma série de ramos alternativos.</dd>
<dt><a id="glos:condicional aninhada" href="05-cond-recur.html#termo:condicional aninhada">condicional aninhada</a></dt>
<dd>Uma instrução condicional que aparece em um dos ramos de outra instrução condicional.</dd>
<dt><a id="glos:instrução de retorno" href="05-cond-recur.html#termo:instrução de retorno">instrução de retorno</a></dt>
<dd>Uma instrução que faz uma função terminar imediatamente e voltar a quem a chamou.</dd>
<dt><a id="glos:recursividade" href="05-cond-recur.html#termo:recursividade">recursividade</a></dt>
<dd>O processo de chamar a função que está sendo executada no momento.</dd>
<dt><a id="glos:caso-base" href="05-cond-recur.html#termo:caso-base">caso-base</a></dt>
<dd>Um ramo condicional em uma função recursiva que não faz uma chamada recursiva.</dd>
<dt><a id="glos:recursividade infinita" href="05-cond-recur.html#termo:recursividade infinita">recursividade infinita</a></dt>
<dd>Recursividade que não tem um caso-base, ou nunca o atinge. A recursividade infinita eventualmente causa um erro em tempo de execução.</dd>
</dl>
<a class="header" href="05-cond-recur.html#514---exercícios" id="514---exercícios"><h2>5.14 - Exercícios</h2></a>
<a class="header" href="05-cond-recur.html#exercício-51" id="exercício-51"><h3>Exercício 5.1</h3></a>
<p>O módulo time fornece uma função, também chamada time, que devolve a Hora Média de Greenwich na “época”, que é um momento arbitrário usado como ponto de referência. Em sistemas UNIX, a época é primeiro de janeiro de 1970.</p>
<pre><code class="language-python">&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time()
1437746094.5735958
</code></pre>
<p>Escreva um script que leia a hora atual e a converta em um tempo em horas, minutos e segundos, mais o número de dias desde a época.</p>
<a class="header" href="05-cond-recur.html#exercício-52" id="exercício-52"><h3>Exercício 5.2</h3></a>
<p>O último teorema de Fermat diz que não existem números inteiros a, b e c tais que <code>a**n + b**n == c**n</code> para quaisquer valores de n maiores que 2.</p>
<ol>
<li>
<p>Escreva uma função chamada check_fermat que receba quatro parâmetros – a, b, c e n – e verifique se o teorema de Fermat se mantém. Se n for maior que 2 e <code>a**n + b**n == c**n</code> o programa deve imprimir, “Holy smokes, Fermat was wrong!” Senão o programa deve exibir “No, that doesn’t work.”</p>
</li>
<li>
<p>Escreva uma função que peça ao usuário para digitar valores para a, b, c e n, os converta em números inteiros e use check_fermat para verificar se violam o teorema de Fermat.</p>
</li>
</ol>
<a class="header" href="05-cond-recur.html#exercício-53" id="exercício-53"><h3>Exercício 5.3</h3></a>
<p>Se você tiver três gravetos, pode ser que consiga arranjá-los em um triângulo ou não. Por exemplo, se um dos gravetos tiver 12 polegadas de comprimento e outros dois tiverem uma polegada de comprimento, não será possível fazer com que os gravetos curtos se encontrem no meio. Há um teste simples para ver se é possível formar um triângulo para quaisquer três comprimentos:</p>
<p>Se algum dos três comprimentos for maior que a soma dos outros dois, então você não pode formar um triângulo. Senão, você pode. (Se a soma de dois comprimentos igualar o terceiro, eles formam um triângulo chamado “degenerado”.)</p>
<ol>
<li>
<p>Escreva uma função chamada <code>is_triangle</code> que receba três números inteiros como argumentos, e que imprima “Yes” ou “No”, dependendo da possibilidade de formar ou não um triângulo de gravetos com os comprimentos dados.</p>
</li>
<li>
<p>Escreva uma função que peça ao usuário para digitar três comprimentos de gravetos, os converta em números inteiros e use <code>is_triangle</code> para verificar se os gravetos com os comprimentos dados podem formar um triângulo.</p>
</li>
</ol>
<a class="header" href="05-cond-recur.html#exercício-54" id="exercício-54"><h3>Exercício 5.4</h3></a>
<p>Qual é a saída do seguinte programa? Desenhe um diagrama da pilha que mostre o estado do programa quando exibir o resultado.</p>
<pre><code class="language-python">def recurse(n, s):
    if n == 0:
        print(s)
    else:
        recurse(n-1, n+s)

recurse(3, 0)
</code></pre>
<ol>
<li>
<p>O que aconteceria se você chamasse esta função desta forma: recurse(-1, 0)?</p>
</li>
<li>
<p>Escreva uma docstring que explique tudo o que alguém precisaria saber para usar esta função (e mais nada).</p>
</li>
</ol>
<p>Os seguintes exercícios usam o módulo turtle, descrito no Capítulo 4:</p>
<a class="header" href="05-cond-recur.html#exercício-55" id="exercício-55"><h3>Exercício 5.5</h3></a>
<p>Leia a próxima função e veja se consegue compreender o que ela faz (veja os exemplos no Capítulo 4). Então execute-a e veja se acertou.</p>
<pre><code class="language-python">def draw(t, length, n):
    if n == 0:
        return
    angle = 50
    t.fd(length * n)
    t.lt(angle)
    draw(t, length, n-1)
    t.rt(2 * angle)
    draw(t, length, n-1)
    t.lt(angle)
    t.bk(length * n)
</code></pre>
<a class="header" href="05-cond-recur.html#exercício-56" id="exercício-56"><h3>Exercício 5.6</h3></a>
<p><img src="https://github.com/PenseAllen/PensePython2e/raw/master/fig/tnkp_0502.png" alt="Figura 5.2 – Uma curva de Koch." />
<br><em>Figura 5.2 – Uma curva de Koch.</em></p>
<p>A curva de Koch é um fractal que parece com o da Figura 5.2. Para desenhar uma curva de Koch com o comprimento x, tudo o que você tem que fazer é:</p>
<ol>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
<li>
<p>Vire 60 graus à esquerda.</p>
</li>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
<li>
<p>Vire 120 graus à direita.</p>
</li>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
<li>
<p>Vire 60 graus à esquerda.</p>
</li>
<li>
<p>Desenhe uma curva de Koch com o comprimento x/3.</p>
</li>
</ol>
<p>A exceção é se x for menor que 3: neste caso, você pode desenhar apenas uma linha reta com o comprimento x.</p>
<ol>
<li>
<p>Escreva uma função chamada koch que receba um turtle e um comprimento como parâmetros, e use o turtle para desenhar uma curva de Koch com o comprimento dado.</p>
</li>
<li>
<p>Escreva uma função chamada snowflake que desenhe três curvas de Koch para fazer o traçado de um floco de neve.</p>
</li>
</ol>
<p>        Solução: http://thinkpython2.com/code/koch.py.</p>
<ol start="3">
<li>A curva de Koch pode ser generalizada de vários modos. Veja exemplos em http://en.wikipedia.org/wiki/Koch_snowflake e implemente o seu favorito.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="04-caso-interface.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="06-funcoes-result.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="04-caso-interface.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="06-funcoes-result.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
